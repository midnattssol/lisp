/* This code was automatically generated by `generate_code.py`. */
#include <map>
#include "./lispvar.h"
std::map<std::string, LispVar *> BUILTINS_TYPES = {};
bool BUILTINS_TYPES_READY = false;
void _fill_out_lisp_builtin_types() {
*_SINGLETON_NOTHING = {NOTHING, 0};
*_SINGLETON_NOT_SET = {__NOT_SET__, 0};
*_SINGLETON_NOARGS_TOKEN = {__NO_ARGS__, 0};
auto type_0 = new LispVar;
auto type_1 = new LispVar;
auto type_2 = new LispVar;
auto type_3 = new LispVar;
auto type_4 = new LispVar;
auto type_5 = new LispVar;
auto type_6 = new LispVar;
auto type_7 = new LispVar;
auto type_8 = new LispVar;
auto type_9 = new LispVar;
auto type_10 = new LispVar;
auto type_11 = new LispVar;
auto type_12 = new LispVar;
auto type_13 = new LispVar;
auto type_14 = new LispVar;
auto type_15 = new LispVar;
auto type_16 = new LispVar;
auto type_17 = new LispVar;
auto type_18 = new LispVar;
auto type_19 = new LispVar;
auto type_20 = new LispVar;
auto type_21 = new LispVar;
auto type_22 = new LispVar;
auto type_23 = new LispVar;
auto type_24 = new LispVar;
auto type_25 = new LispVar;
auto type_26 = new LispVar;
auto type_27 = new LispVar;
*type_0 = parse_and_evaluate("[(map type [\"*\"])]");
*type_1 = parse_and_evaluate("[(map type [\"+\"])]");
*type_2 = parse_and_evaluate("[(map type [\"int\"])]");
*type_3 = parse_and_evaluate("[(map type [\"any\"])]");
*type_4 = parse_and_evaluate("[(map type [\"list\"])]");
*type_5 = parse_and_evaluate("[(map type [\"booly\"])]");
*type_6 = parse_and_evaluate("[(map type [\"string\"])]");
*type_7 = parse_and_evaluate("[(map type [\"numeric\"])]");
*type_8 = parse_and_evaluate("[(map type [\"*\" \"list\"])]");
*type_9 = parse_and_evaluate("[(map type [\"expression\"])]");
*type_10 = parse_and_evaluate("[(map type [\"*\" \"numeric\"])]");
*type_11 = parse_and_evaluate("[(map type [\"int\"]) (map type [\"any\"])]");
*type_12 = parse_and_evaluate("[(map type [\"int\"]) (map type [\"int\"])]");
*type_13 = parse_and_evaluate("[(map type [\"list\"]) (map type [\"any\"])]");
*type_14 = parse_and_evaluate("[(map type [\"int\"]) (map type [\"list\"])]");
*type_15 = parse_and_evaluate("[(map type [\"list\"]) (map type [\"list\"])]");
*type_16 = parse_and_evaluate("[(map type [\"string\"]) (map type [\"any\"])]");
*type_17 = parse_and_evaluate("[(map type [\"string\"]) (map type [\"string\"])]");
*type_18 = parse_and_evaluate("[(map type [\"numeric\"]) (map type [\"numeric\"])]");
*type_19 = parse_and_evaluate("[(map type [\"callable\"]) (map type [\"any\" \"*\"])]");
*type_20 = parse_and_evaluate("[(map type [\"booly\"]) (map type [\"string\" \"?\"])]");
*type_21 = parse_and_evaluate("[(map type [\"callable\"]) (map type [\"list\" \"*\"])]");
*type_22 = parse_and_evaluate("[(map type [\"expression\"]) (map type [\"expression\"])]");
*type_23 = parse_and_evaluate("[(map type [\"any\"]) (map type [\"int\"]) (map type [\"list\"])]");
*type_24 = parse_and_evaluate("[(map type [\"booly\"]) (map type [\"any\"]) (map type [\"any\"])]");
*type_25 = parse_and_evaluate("[(map type [\"callable\"]) (map type [\"?\"]) (map type [\"list\"])]");
*type_26 = parse_and_evaluate("[(map type [\"int\" \"?\"]) (map type [\"int\" \"?\"]) (map type [\"int\" \"?\" \"truthy\"])]");
*type_27 = parse_and_evaluate("[(map type [\"list\"]) (map type [\"int\"]) (map type [\"int\" \"?\"]) (map type [\"int\" \"?\"])]");
BUILTINS_TYPES["do"] = type_1;
BUILTINS_TYPES["eq"] = type_0;
BUILTINS_TYPES["gt"] = type_10;
BUILTINS_TYPES["lt"] = type_10;
BUILTINS_TYPES["or"] = type_10;
BUILTINS_TYPES["add"] = type_10;
BUILTINS_TYPES["and"] = type_10;
BUILTINS_TYPES["div"] = type_18;
BUILTINS_TYPES["geq"] = type_10;
BUILTINS_TYPES["get"] = type_14;
BUILTINS_TYPES["len"] = type_4;
BUILTINS_TYPES["leq"] = type_10;
BUILTINS_TYPES["let"] = type_16;
BUILTINS_TYPES["map"] = type_21;
BUILTINS_TYPES["mod"] = type_12;
BUILTINS_TYPES["mul"] = type_10;
BUILTINS_TYPES["neg"] = type_7;
BUILTINS_TYPES["neq"] = type_0;
BUILTINS_TYPES["pop"] = type_4;
BUILTINS_TYPES["put"] = type_3;
BUILTINS_TYPES["sub"] = type_18;
BUILTINS_TYPES["xor"] = type_10;
BUILTINS_TYPES["bool"] = type_5;
BUILTINS_TYPES["call"] = type_19;
BUILTINS_TYPES["eval"] = type_4;
BUILTINS_TYPES["exit"] = type_2;
BUILTINS_TYPES["flip"] = type_2;
BUILTINS_TYPES["fold"] = type_25;
BUILTINS_TYPES["help"] = type_3;
BUILTINS_TYPES["join"] = type_8;
BUILTINS_TYPES["list"] = type_0;
BUILTINS_TYPES["noop"] = type_0;
BUILTINS_TYPES["push"] = type_13;
BUILTINS_TYPES["rand"] = type_2;
BUILTINS_TYPES["repr"] = type_3;
BUILTINS_TYPES["type"] = type_6;
BUILTINS_TYPES["match"] = type_17;
BUILTINS_TYPES["range"] = type_26;
BUILTINS_TYPES["slice"] = type_27;
BUILTINS_TYPES["while"] = type_22;
BUILTINS_TYPES["assert"] = type_20;
BUILTINS_TYPES["insert"] = type_23;
BUILTINS_TYPES["repeat"] = type_11;
BUILTINS_TYPES["symbol"] = type_3;
BUILTINS_TYPES["typeof"] = type_3;
BUILTINS_TYPES["closure"] = type_9;
BUILTINS_TYPES["ternary"] = type_24;
BUILTINS_TYPES["eval_expr"] = type_9;
BUILTINS_TYPES["typematch"] = type_15;
BUILTINS_TYPES["expression"] = type_0;
BUILTINS_TYPES_READY = true;
}
